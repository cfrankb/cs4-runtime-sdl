from datetime import datetime
today = datetime.today()

NOTICE:str = f'''/*
    cs4-runtime-sdl
    Copyright (C) {today.year} Francois Blanchette

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
\n'''

TILEDEF:str = '''
const tiledef_t &getTileDef(int i)
{
    return tileDefs[i];
}
'''

TILEDEF_STRUCT:str='''typedef struct
{
    uint8_t flags;
    uint8_t type;
    uint8_t score;
    int8_t health;
    uint8_t speed;
    uint8_t ai;
    bool hidden;
    const char * basename;
} tiledef_t;

const tiledef_t & getTileDef(int i);

'''

class TileDef:
    flag = '0x00'
    type_name = ''
    score = 0
    hp = 0
    speed = 0
    ai = 0
    hidden = False
    basename = ''
    tile_id = 0
    def_name = ''

    def to_string(self):
        item_def = f'''{{{self.flag}, TYPE_{self.type_name}, {self.score}, {self.hp}, {self.speed}, {self.ai}, {'true' if self.hidden else 'false'}, "{self.basename}"}}, '''
        return f'''     {item_def:70} // {self.tile_id:0>2x} {self.def_name}'''

def get_pair(line:str) -> list[str]:
    pair = []
    for e in line.split(' '):
        e = e.strip()
        if not e:
            continue
        if e[0] == '#':
            break
        pair.append(e)
    return pair

def main():
    defines:list[str] = ['//////////////////////////////////////////////////',
               '// autogenerated',
               '#include <stdint.h>'
               '',
               '#pragma once',
               '',
               TILEDEF_STRUCT
               ]

    data:list[str] = [
        '//////////////////////////////////////////////////',
        '// autogenerated',
        '',
        '#include "tilesdata.h"',
        '',
        'const tiledef_t tileDefs[] = {'
    ]

    tile_defs = []
    tiles = {}
    cache = {}
    lines = list[str]
    with open ('tiles.ini') as sfile:
        lines = sfile.read().split('\n')

    section:str = None
    line_num:int = 0
    i:int = 0
    for line in lines:
        line_num += 1
        line = line.strip().replace('\t', ' ')
        if not line or line[0] == '#':
            # skip empty lines and comments
            pass
        elif line[0] == '[':
            # process section head
            if section:
                defines.append('')
            section = line[1:-1].lower()
            if section != 'tiledefs':
                defines.append(f'// {section}')
            i = 0
        elif section:
            pair = get_pair(line)
            if not pair:
                continue
            def_name = pair[0].upper()
            def_name_raw = def_name
            prefix = def_name[0:len(section)]
            if prefix.upper() != section.upper():
                def_name = f'{section.upper()}_{def_name}'
            c = line.split('#',1)
            name = c[1].strip() if len(c) > 1 else ''
            k = 1
            val = i
            if len(pair) > 1 and len(pair[1]) in (2,3) and pair[1][0].isalnum():
                try:
                    val = int(pair[1],16)
                except:
                    print(f'warning: failed to parse `{pair[1]}` as hex value on line {line_num}')
                k = 2
            if section not in cache:
                cache[section] = {}
            cache[section][def_name_raw.lower()] = val

            if section == 'tiledefs':
                if def_name_raw not in tiles:
                    print(f'error: missing tile {def_name_raw} in tiles on line {line_num}')
                    continue
                tile_id = tiles[def_name_raw]
                for j in range(1, len(pair)):
                    e = pair[j].split(':')
                    if (len(e) != 2):
                        print(f"error: invalid pair value `{pair[j]}` on line {line_num}")
                        continue
                    k,v= tuple(e)
                    if v[0] in ('-', '+') or v[0].isnumeric():
                        value = v
                    else:
                        kl = k.lower()
                        vl = v.lower()
                        if kl in cache and vl not in cache[kl]:
                            print(f"error: `{vl}` missing from `{kl}` on line {line_num}")
                        value = f'{k.upper()}_{v.upper()}'
                    if not hasattr(tile_defs[tile_id], k):
                        print(f"error: invalid attr `{k}` on line {line_num}")
                    else:
                        setattr(tile_defs[tile_id], k, value)
            else:
                defines.append(f'#define {def_name:32} 0x{val:0>2x}' + (f' // {name}' if name else ''))

            if section == 'tiles':
                tiles[def_name] = val
                score = 0
                hp = 0
                if len(pair) > k + 1:
                    for j in range(k + 1, len(pair)):
                        if pair[j][0] == '+':
                           hp = int(pair[j][1:])
                        elif pair[j][0] == '-':
                           hp = int(pair[j])
                        elif pair[j][0] == '$':
                           score = int(pair[j][1:])
                        else:
                            print(f'invalid tile param `${pair[j]}` on line ${line}')
                if len(pair) > k:
                    type_name = pair[k]
                    if type_name.lower() not in cache['type']:
                        print(f'type_name {type_name} on line {line_num} not found')
                    else:
                        tile = TileDef()
                        tile.type_name = type_name
                        tile.score = score
                        tile.hp = hp
                        tile.basename = name
                        tile.tile_id = val
                        tile.def_name = def_name
                        tile_defs.append(tile)
                else:
                    print(f'warning: no type defined on line {line_num}')
            i += 1
        else:
            print(f'value no in section on line {line_num}')

    for line in tile_defs:
        data.append(line.to_string())

    with open('../../src/tilesdata.h', 'w') as tfile:
        tfile.write(NOTICE)
        tfile.write('\n'.join(defines))

    with open('../../src/tilesdata.cpp', 'w') as tfile:
        tfile.write(NOTICE)
        data.append('};')
        data.append(TILEDEF)
        tfile.write('\n'.join(data))

main()
